1. This lab serializes a `User` object within the user's session cookie. The object as an `admin` field, which can be modified to gain admin access. By decoding the cookie from base64, changing the `admin` field to the value `1`, encoding the new cookie with base64, and overriding the original cookie with this modified one, you can gain access to the admin panel at `/admin`. The following is the decoded original cookie: `O:4:"User":2:{s:8:"username";s:6:"wiener";s:5:"admin";b:0;}`
2. This lab is the same as the previous, but this time uses an `access_token` string and a username in order to store user information. The `access_token` can be overriden from a string to the integer `0` in order to match any string that doesn't begin with a number due to PHP's `==` operator being used. The following payload is the decoded modified cookie: `O:4:"User":2:{s:8:"username";s:13:"administrator";s:12:"access_token";i:0;}`
3. This lab is the same as the previous, but with the addition of an avatar image. The path to this image is stored within the serialized `User` object, and as such can be odified. Because the site deletes the file at this path when a user account is deleted, modifying this file then deleting your own account can be used to delete arbitrary files on the server. The following shows the decoded and modified cookie: `O:4:"User":3:{s:8:"username";s:5:"gregg";s:12:"access_token";s:32:"ofw72j87ntic2aplo9w38yp1d67rdxt1";s:11:"avatar_link";s:23:"/home/carlos/morale.txt";}`
4. This lab is the same as the previous one, but without a clear way to delete the arbitrary file. By checking the source code, you can find references to `/libs/CustomTemplate.php`. Navigating to `/libs/CustomTemplate.php~`, you can view an editor-saved backup of the file and therefore view the source. This shows a custom type that deletes a file pointed to by one of its attributes once the object itself is deleted. Because this type is serializable, you can make your session cookie be a serialized instance of this type instead of the expected `User` type in order to delete the specified file. The following payload works: `O:14:"CustomTemplate":2:{s:18:"template_file_path";s:6:"wiener";s:14:"lock_file_path";s:23:"/home/carlos/morale.txt";}`
5. This lab is about using premade exploit chains on other websites that have insecure deserialization using the same libraries. It requires using an external tool that I could not get to work, however, so I was unable to solve it
6. This lab also requires using premade exploit chains to solve the lab. It would have taken a long amount of time for little gain to install the tool and its dependencies, so I skipped this lab
7. This lab involved looking online to find someone's premade exploit chain and modifying the final command executed to run the command on the victim server that we want instead of the example one that came with the online version. This would also have taken too long for essentially no benefit so I skipped it
8. This lab has a serialized Java object stored in the session cookie. By observing the site's source, you can find references to the `/backup` endpoint, which is a directory listing with the source code to some files. While one is not interesting, `ProductTemplate.java` is a serializable object whose `id` is vulnerable to a SQL injection. Using the `ORDER BY` attack with a binary search, I was able to discover that there are 8 items being returned from the query. By enumerating between selecting values of `NULL` with one `'a'`, I found that positions 4 and 5 do not expect strings, and will echo their contents if one is provided. I was able to extract the table names using the payload `' UNION SELECT NULL,NULL,NULL,CAST(string_agg(table_name, ', ') AS numeric),NULL,NULL,NULL,NULL FROM information_schema.tables--` and the columns of that table using the payload `' UNION SELECT NULL,NULL,NULL,CAST(string_agg(column_name, ', ') AS numeric),NULL,NULL,NULL,NULL FROM information_schema.columns WHERE table_name='users'--`. I managed to extract the administrator's password using the payload `' UNION SELECT NULL,NULL,NULL,CAST(password AS numeric),NULL,NULL,NULL,NULL FROM users WHERE username='administrator'--`. The Java code to generate the final password extracting payload can be found in `serialization-examples/java/solution`
9. This lab has a serialized PHP object stored in the session cookie. By observing the site's source, you can find references to `https://ac6b1f641e131afbc0659a7e00ad009f.web-security-academy.net/cgi-bin/libs/CustomTemplate.php`, and an editor-saved backup of that file can be viewed by appending a `~` to the end of the `.php` extension, thus retrieving source. In the source, the important parts are that the `CustomTemplate` class is serializable and will create a `Product` when it is deserialized, and that `DefaultMap` will execute a saved callback function when an invalid attribute is accessed as a result of its `__get()` magic method. As a result, the following payload can be used to achieve RCE with this gadget chain and solve the lab: `O:14:"CustomTemplate":2:{s:17:"default_desc_type";s:26:"rm /home/carlos/morale.txt";s:4:"desc";O:10:"DefaultMap":1:{s:8:"callback";s:4:"exec";}}`
10. This lab doesn't obviously use deserialization in any way. It allows for file upload, and has a theoretical gadget chain using the `Blog` and `CustomTemplate` classes that can be found by requesting `/cgi-bin` and receiving an index. It should be noted that uploaded user profiles are accessed at `/cgi-bin/avatar.php?avatar=wiener`. By uploading a PHAR/JPG polyglot, we can access it at `/cgi-bin/avatar.php?avatar=phar://wiener` to cause it to be accessed as a PHAR and therefore deserialized, triggering an insecure deserialization vulnerability. The polyglot that I used was an example one provided from PortSwigger and can be found at `serialization-examples/php/phar-jpg-polyglot.jpg`
