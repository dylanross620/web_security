1. This lab has nothing preventing uploading a PHP file in place of an image. As such, uploading the file `exploit.php` and navigating to it in a web browser revealed the contents of the secret file
2. This lab attempts to verify the file type by checking the `Content-Type` header of the form data. However, by using a MITM setup, this can be spoofed to be a valid image type such as `image/jpeg` while actually being a PHP file such as `exploit.php`
3. This lab does not prevent uploading PHP files, but does prevent executing scripts within the `avatars` directory and strips out any `../` sequences in the filename. However, this can be bypassed by using URL encoding, so uploading a file like `..%2fexploit.php` can bypass the filter and get executed
4. This lab blocks the `.php` extension, but allows for uploading a custom `.htaccess` file. As such, the server can be exploited by uploading a file named `.htaccess` that contains the line `AddType application/x-httpd-php .exploit`. This associates files with the `.exploit` file extension as PHP files to be executed and as such allows bypassing the blacklisted file extensions
5. This lab enforces that uploaded filenames end in `.png` or `.jpg`, but the implementation doesn't match the string interpretation done by the web server. As such, uploading a file with the name `exploit.php%00.jpg` passes the initial check as it doesn't URL decode and/or use C-style strings, but the webserver does both of these things. As such, the file gets uploaded as `exploit.php` and can be retrieved as such
6. This lab attempts to validate file type by fingerprinting it on the server side. However, file names are not checked, so making a polyglot JPG/PHP file with a `.php` extension allows for passing the filetype check while executing PHP code. This can be done using exiftool as follows: `exiftool -Comment='<?php echo "<h1>"; echo file_get_contents("/home/carlos/secret"); echo "</h1>"; ?>' image.php`
7. This lab has a race condition, where it uploads the file to the server, spends some time verifying that it's safe, then deletes it if not. Due to this behavior, there is a window of time where the file is on the server and servable before it is found to be malicious. This can be exploited by sending the POST request to upload the file, then immediately sending GET requests to retrieve it from the server before it is deleted. This could be scripted, but I did so using the Turbo Intruder extension for Burp Suite as it has less boilerplate code to set up
